"""Compile and visualize ablation study results.

Reads ablation results from JSON (generated by run_ablation.py) and
produces comparison tables and plots for the Phase 2 report.

Usage:
    python scripts/compile_ablation_results.py
    python scripts/compile_ablation_results.py --input results/ablation_results.json
    python scripts/compile_ablation_results.py --wandb-group phase2-ablation
"""

import argparse
import json
import os
import sys
from collections import defaultdict
from pathlib import Path

sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

import numpy as np


def load_results(input_path: str) -> list[dict]:
    """Load ablation results from JSON file."""
    with open(input_path) as f:
        return json.load(f)


def aggregate_by_config(results: list[dict]) -> dict[str, dict]:
    """Aggregate results by config label across seeds.

    Returns:
        Dict mapping config label to aggregate metrics.
    """
    by_config = defaultdict(list)
    for r in results:
        by_config[r["config"]].append(r)

    aggregated = {}
    for label, runs in sorted(by_config.items()):
        capture_rates = [r["capture_rate"] for r in runs]
        violations = [r["violations"] for r in runs]
        intervention_rates = [r["intervention_rate"] for r in runs]
        backup_rates = [r["backup_rate"] for r in runs]
        exact_rates = [r["exact_rate"] for r in runs]
        margins = [r["mean_cbf_margin"] for r in runs
                   if not (isinstance(r["mean_cbf_margin"], float)
                           and np.isnan(r["mean_cbf_margin"]))]

        aggregated[label] = {
            "n_seeds": len(runs),
            "capture_rate_mean": float(np.mean(capture_rates)),
            "capture_rate_std": float(np.std(capture_rates)),
            "violations_mean": float(np.mean(violations)),
            "violations_total": int(sum(violations)),
            "intervention_rate_mean": float(np.mean(intervention_rates)),
            "intervention_rate_std": float(np.std(intervention_rates)),
            "backup_rate_mean": float(np.mean(backup_rates)),
            "exact_rate_mean": float(np.mean(exact_rates)),
            "exact_rate_std": float(np.std(exact_rates)),
            "cbf_margin_mean": float(np.mean(margins)) if margins else float("nan"),
            "all_targets_met": all(r["all_targets_met"] for r in runs),
        }

    return aggregated


def generate_latex_table(aggregated: dict[str, dict]) -> str:
    """Generate LaTeX table for the Phase 2 report."""
    config_descriptions = {
        "A": "Full safe (CBF-$\\beta$ + $w_5$ + N13)",
        "B": "Unsafe baseline (no CBF)",
        "C": "QP filter only (post-hoc)",
        "D": "CBF-$\\beta$, no $w_5$",
        "E": "CBF-$\\beta$ + $w_5$, no N13",
    }

    lines = [
        "\\begin{table}[htbp]",
        "\\centering",
        "\\caption{Phase 2 Ablation Study Results}",
        "\\label{tab:ablation}",
        "\\begin{tabular}{llccccc}",
        "\\toprule",
        "Config & Description & Capture & Violations & Interv.\\% & Exact\\% & Targets \\\\",
        "\\midrule",
    ]

    for label in ["A", "B", "C", "D", "E"]:
        if label not in aggregated:
            continue
        a = aggregated[label]
        desc = config_descriptions.get(label, label)
        cr = f"{a['capture_rate_mean']:.3f}"
        viol = f"{a['violations_total']}"
        interv = f"{a['intervention_rate_mean']:.3f}"
        exact = f"{a['exact_rate_mean']:.3f}"
        targets = "\\checkmark" if a["all_targets_met"] else "\\times"
        lines.append(f"{label} & {desc} & {cr} & {viol} & {interv} & {exact} & {targets} \\\\")

    lines.extend([
        "\\bottomrule",
        "\\end{tabular}",
        "\\end{table}",
    ])

    return "\n".join(lines)


def generate_markdown_table(aggregated: dict[str, dict]) -> str:
    """Generate Markdown comparison table."""
    config_descriptions = {
        "A": "Full safe (CBF-Beta + w5 + N13)",
        "B": "Unsafe baseline (no CBF)",
        "C": "QP filter only (post-hoc)",
        "D": "CBF-Beta, no w5",
        "E": "CBF-Beta + w5, no N13",
    }

    lines = [
        "| Config | Description | Capture Rate | Violations | Interv. % | Exact % | CBF Margin | Targets |",
        "|--------|-------------|:------------:|:----------:|:---------:|:-------:|:----------:|:-------:|",
    ]

    for label in ["A", "B", "C", "D", "E"]:
        if label not in aggregated:
            continue
        a = aggregated[label]
        desc = config_descriptions.get(label, label)
        cr = f"{a['capture_rate_mean']:.3f}"
        viol = f"{a['violations_total']}"
        interv = f"{a['intervention_rate_mean']:.3f}"
        exact = f"{a['exact_rate_mean']:.3f}"
        margin = f"{a['cbf_margin_mean']:.3f}" if not np.isnan(a["cbf_margin_mean"]) else "N/A"
        targets = "PASS" if a["all_targets_met"] else "FAIL"
        lines.append(
            f"| {label} | {desc} | {cr} | {viol} | {interv} | {exact} | {margin} | {targets} |"
        )

    return "\n".join(lines)


def generate_analysis(aggregated: dict[str, dict]) -> str:
    """Generate textual analysis of ablation results."""
    lines = ["## Analysis\n"]

    if "A" in aggregated and "B" in aggregated:
        a, b = aggregated["A"], aggregated["B"]
        cr_diff = b["capture_rate_mean"] - a["capture_rate_mean"]
        lines.append(f"**Safety cost**: Config A capture rate "
                     f"({a['capture_rate_mean']:.3f}) vs Config B "
                     f"({b['capture_rate_mean']:.3f}): "
                     f"{'modest' if abs(cr_diff) < 0.1 else 'significant'} "
                     f"difference ({cr_diff:+.3f}).")

    if "A" in aggregated and "C" in aggregated:
        a, c = aggregated["A"], aggregated["C"]
        lines.append(f"\n**CBF-Beta vs QP-only**: Config A intervention rate "
                     f"({a['intervention_rate_mean']:.3f}) vs Config C "
                     f"({c['intervention_rate_mean']:.3f}). "
                     f"{'Beta reduces interventions' if a['intervention_rate_mean'] < c['intervention_rate_mean'] else 'QP has fewer interventions'}.")

    if "A" in aggregated and "D" in aggregated:
        a, d = aggregated["A"], aggregated["D"]
        lines.append(f"\n**w5 effect**: Config A intervention rate "
                     f"({a['intervention_rate_mean']:.3f}) vs Config D "
                     f"({d['intervention_rate_mean']:.3f}). "
                     f"Safety reward {'reduces' if a['intervention_rate_mean'] < d['intervention_rate_mean'] else 'does not reduce'} interventions.")

    if "A" in aggregated and "E" in aggregated:
        a, e = aggregated["A"], aggregated["E"]
        lines.append(f"\n**N13 effect**: Config A exact rate "
                     f"({a['exact_rate_mean']:.3f}) vs Config E "
                     f"({e['exact_rate_mean']:.3f}). "
                     f"Feasibility classifier {'improves' if a['exact_rate_mean'] > e['exact_rate_mean'] else 'does not improve'} feasibility.")

    return "\n".join(lines)


def try_generate_plots(results: list[dict], output_dir: str):
    """Generate comparison plots if matplotlib is available."""
    try:
        import matplotlib
        matplotlib.use("Agg")
        import matplotlib.pyplot as plt
    except ImportError:
        print("matplotlib not available — skipping plots")
        return

    Path(output_dir).mkdir(parents=True, exist_ok=True)
    aggregated = aggregate_by_config(results)
    labels = sorted(aggregated.keys())

    # 1. Capture rate bar chart
    fig, ax = plt.subplots(figsize=(8, 5))
    x = np.arange(len(labels))
    means = [aggregated[l]["capture_rate_mean"] for l in labels]
    stds = [aggregated[l]["capture_rate_std"] for l in labels]
    ax.bar(x, means, yerr=stds, capsize=5, color=["#2ecc71", "#e74c3c", "#3498db", "#f39c12", "#9b59b6"])
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.set_ylabel("Capture Rate")
    ax.set_title("Task Performance by Config")
    ax.set_ylim(0, 1)
    fig.tight_layout()
    fig.savefig(os.path.join(output_dir, "capture_rate.png"), dpi=150)
    plt.close(fig)
    print(f"  Plot saved: {output_dir}/capture_rate.png")

    # 2. Intervention rate bar chart
    fig, ax = plt.subplots(figsize=(8, 5))
    means = [aggregated[l]["intervention_rate_mean"] for l in labels]
    stds = [aggregated[l]["intervention_rate_std"] for l in labels]
    ax.bar(x, means, yerr=stds, capsize=5, color=["#2ecc71", "#e74c3c", "#3498db", "#f39c12", "#9b59b6"])
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.set_ylabel("Intervention Rate")
    ax.set_title("CBF Intervention Rate by Config")
    fig.tight_layout()
    fig.savefig(os.path.join(output_dir, "intervention_rate.png"), dpi=150)
    plt.close(fig)
    print(f"  Plot saved: {output_dir}/intervention_rate.png")

    # 3. Safety summary (violations + exact rate)
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

    violations = [aggregated[l]["violations_total"] for l in labels]
    ax1.bar(x, violations, color=["#2ecc71", "#e74c3c", "#3498db", "#f39c12", "#9b59b6"])
    ax1.set_xticks(x)
    ax1.set_xticklabels(labels)
    ax1.set_ylabel("Total Violations")
    ax1.set_title("Safety Violations")

    exact = [aggregated[l]["exact_rate_mean"] for l in labels]
    ax2.bar(x, exact, color=["#2ecc71", "#e74c3c", "#3498db", "#f39c12", "#9b59b6"])
    ax2.set_xticks(x)
    ax2.set_xticklabels(labels)
    ax2.set_ylabel("Exact Rate")
    ax2.set_title("CBF Exact Solve Rate")
    ax2.set_ylim(0, 1)

    fig.tight_layout()
    fig.savefig(os.path.join(output_dir, "safety_summary.png"), dpi=150)
    plt.close(fig)
    print(f"  Plot saved: {output_dir}/safety_summary.png")


def compile_wandb_results(group: str) -> list[dict]:
    """Compile results from wandb API (requires wandb login).

    Args:
        group: wandb group name (e.g., "phase2-ablation").

    Returns:
        List of result dicts matching run_ablation.py format.
    """
    try:
        import wandb
    except ImportError:
        print("wandb not available — cannot compile wandb results")
        return []

    api = wandb.Api()
    runs = api.runs("pursuit-evasion", filters={"group": group})

    results = []
    for run in runs:
        config_name = run.config.get("experiment", {}).get("name", run.name)
        # Extract config letter from name (e.g., "ablation_A_full_safe" -> "A")
        label = "?"
        for letter in "ABCDE":
            if f"_{letter}_" in config_name or config_name.endswith(f"_{letter}"):
                label = letter
                break

        results.append({
            "config": label,
            "seed": run.config.get("seed", 0),
            "n_episodes": -1,  # full training
            "capture_rate": run.summary.get("pe/capture_rate", 0.0),
            "violations": run.summary.get("safety/violations", 0),
            "violation_rate": run.summary.get("safety/violation_rate", 0.0),
            "intervention_rate": run.summary.get("safety/cbf_intervention_rate", 0.0),
            "backup_rate": run.summary.get("safety/backup_rate", 0.0),
            "feasibility_rate": run.summary.get("safety/feasibility_rate", 1.0),
            "exact_rate": run.summary.get("safety/exact_rate", 1.0),
            "min_cbf_margin": run.summary.get("safety/min_cbf_margin", float("nan")),
            "mean_cbf_margin": run.summary.get("safety/mean_cbf_margin", float("nan")),
            "all_targets_met": run.summary.get("safety/violations", 0) == 0,
        })

    return results


def main():
    parser = argparse.ArgumentParser(description="Compile ablation results")
    parser.add_argument(
        "--input", type=str, default="results/ablation_results.json",
        help="Input JSON file from run_ablation.py",
    )
    parser.add_argument(
        "--output-dir", type=str, default="results/ablation",
        help="Output directory for tables and plots",
    )
    parser.add_argument(
        "--wandb-group", type=str, default=None,
        help="Compile from wandb group instead of JSON file",
    )
    args = parser.parse_args()

    # Load results
    if args.wandb_group:
        results = compile_wandb_results(args.wandb_group)
        if not results:
            return
    else:
        if not Path(args.input).exists():
            print(f"Results file not found: {args.input}")
            print("Run `python scripts/run_ablation.py` first.")
            return
        results = load_results(args.input)

    print(f"Loaded {len(results)} results")

    # Aggregate
    aggregated = aggregate_by_config(results)

    # Generate outputs
    Path(args.output_dir).mkdir(parents=True, exist_ok=True)

    # Markdown table
    md_table = generate_markdown_table(aggregated)
    print("\n" + md_table)

    # Analysis
    analysis = generate_analysis(aggregated)
    print("\n" + analysis)

    # Save markdown report
    report = f"# Phase 2 Ablation Study Results\n\n{md_table}\n\n{analysis}\n"
    report_path = os.path.join(args.output_dir, "ablation_report.md")
    with open(report_path, "w") as f:
        f.write(report)
    print(f"\nReport saved: {report_path}")

    # LaTeX table
    latex = generate_latex_table(aggregated)
    latex_path = os.path.join(args.output_dir, "ablation_table.tex")
    with open(latex_path, "w") as f:
        f.write(latex)
    print(f"LaTeX table saved: {latex_path}")

    # Plots
    try_generate_plots(results, args.output_dir)


if __name__ == "__main__":
    main()
